"use strict"

// This file autogenerated by langlang.
// For details, see {{ help_url }}.

class Parser {
    __tokens = {
{{ tokens }}
        "__whitespace": /^(?:\s|\n)+/,
        "__unknown": /^[^\s\n]+/,
    }

    __tokenize(s) {
        let tokens = [];
        nextToken: while (s.length > 0) {
            for (let type in this.__tokens) {
                let result = this.__tokens[type].exec(s);
                if (result !== null) {
                    if (type != '__whitespace') {
                        tokens.push({
                            type: type,
                            value: result[0],
                        });
                    }
                    s = s.slice(result[0].length);
                    continue nextToken;
                }
            }
            throw Error(`Internal error (this should never happen): ${s}`)
        }
        return tokens;
    }

    constructor(input) {
        this.tokens = this.__tokenize(input);
        this.index = 0;
    }

    __next() {
        let token = this.tokens[this.index];
        if (token === undefined) {
            throw Error('Unexpected end of file.')
        }
        if (token.type === '___unknown') {
            throw Error(`Unknown token: "${token.value}"`)
        }
        this.index++;
        return token;
    }

    __require(type) {
        // console.debug(`Requiring: ${type}`)
        let token = this.__next();
        if (token.type !== type) {
            throw Error(`Expected ${type}, got ${token.type}`)
        }
        return token;
    }

    __consume_all(parser) {
        let result = this[parser]();
        if (this.index < this.tokens.length) {
            throw Error(`Remaining tokens: ${this.tokens.slice(this.index).map((t) => t.value)}`)
        }
        return result;
    }

    // Parser helper functions
    __try(parser) {
        // Returns the parser result, or null if the parser failed.
        let backup = this.index;
        try {
            return parser.call(this);
        }
        catch (e) {
            this.index = backup;
            return null;
        }
    }

    __test(parser) {
        // Returns true if the parser would succeed, false if it would not.
        let backup = this.index;
        try {
            parser.call(this);
            return true;
        }
        catch (e) {
            return false;
        }
        finally {
            this.index = backup;
        }
    }

{{ parsers }}
}

{{ exports }}